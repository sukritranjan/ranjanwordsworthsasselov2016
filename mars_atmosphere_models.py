# -*- coding: iso-8859-1 -*-
"""
Purpose of this file is to calculate atmospheric profiles for the Martian atmosphere. Specifically, it is to calculate T, P, n, P_sat_h2o, and P_sat_co2 as functions of altitude. The effects of CO2 condensation are included, though in truth UV surface radiances are insensitive to the details of the T/P profile. A detailed description is available in Ranjan, Wordsworth and Sasselov 2016.

Two functions are provided. One is for a CO2-H2O atmosphere, and is designed with a cold, dry Martian atmosphere (a la Wordsworth+2013) in mind. The other is for a planet with a significant inventory of volcanogenic gases a la Halevy+2014 in mind (CO2-H2O-SO2-H2S).

Each function call produces two files as output. These are a 1D T/P profile and a 1D molar concentration profile

We output this model in a form usable by our RT code. (high resolution, preferably ~0.1 km or better, required)
"""

########################
###Import useful libraries
########################
import numpy as np
import matplotlib.pyplot as plt
import pdb
import scipy.integrate
import scipy.optimize
from matplotlib.pyplot import cm
import thermodynamic_functions as thermo

########################
###Define useful constants, all in CGS (via http://www.astro.wisc.edu/~dolan/constants.html)
########################

#Unit conversions
km2m=1.e3 #1 km in m
km2cm=1.e5 #1 km in cm
cm2km=1.e-5 #1 cm in km
amu2g=1.66054e-24 #1 amu in g
bar2atm=0.9869 #1 bar in atm
Pascal2bar=1.e-5 #1 Pascal in bar
Pa2bar=1.e-5 #1 Pascal in bar
bar2Pa=1.e5 #1 bar in Pascal
deg2rad=np.pi/180.
bar2barye=1.e6 #1 Bar in Barye (the cgs unit of pressure)
barye2bar=1.e-6 #1 Barye in Bar
micron2m=1.e-6 #1 micron in m
micron2cm=1.e-4 #1 micron in cm
metricton2kg=1000. #1 metric ton in kg

#Fundamental constants
c=2.997924e10 #speed of light, cm/s
h=6.6260755e-27 #planck constant, erg/s
k=1.380658e-16 #boltzmann constant, erg/K
sigma=5.67051e-5 #Stefan-Boltzmann constant, erg/(cm^2 K^4 s)
R_earth=6371.*km2m#radius of earth in m
R_sun=69.63e9 #radius of sun in cm
AU=1.496e13#1AU in cm

#Mean molecular masses
m_co2=44.01*amu2g #co2, in g
m_h2o=18.02*amu2g #h2o, in g

#Mars parameters
g=371. #surface gravity of Mars, cm/s**2, from: http://nssdc.gsfc.nasa.gov/planetary/factsheet/marsfact.html


########################
###CO2-H2O Atmosphere, cold and dry (e.g. Wordsworth+2013)
########################
def generate_profiles_cold_dry_mars(P_0_bar, T_0, savefilename):
	"""
	Generates input files for a cold, dry Martian atmosphere (CO2+H2O, thermodynamics totally CO2-dominated)
	P_0_bar: Dry CO2 surface pressure in Bar
	T_0: surface temperature in K
	savefilename: name the output files generated by the function will be saved with
	"""
	P_0=P_0_bar*bar2barye #Dry CO2 surface pressure, from bar-->barye. Specified when you assume an atmospheric thickness

	P_strat_0=0.1*bar2barye #pressure at which the stratosphere starts, based on the insight by Robinson & Catling 2013 that terrestrial triatomic atmospheres tend to have stratospheres starting at p~0.1 because that's where radiative windows open up and radiative cooling/heating start to dominate

	#Specific heat at constant pressures for gases
	c_p_co2=thermo.c_p_shomate('co2', T_0) #converted from kJ/(Kg*K) to erg/(g*K)
	c_p_h2o=1.97*1.e7 #converted from kJ/(Kg*K) to erg/(g*K), measured at 1 atm and 338-589 F ()

	#Latent heats/enthalpies
	L_co2=5.93e5*1.e4 #Heat of sublimation of CO2. Value taken from PPC Table 2.1 p 92, converted from SI (Joule/Kg) to erg/gram. Taken as constant.
	#print (L_co2/(k/m_co2))/(3138.) #should be close to 1...and is, to <0.1%


	#gas composition of atmosphere
	mmm=m_co2 #mean molecular mass in g
	c_p=c_p_co2 #mean specific heat at constant pressure for atmosphere

	R_atm=k/mmm #specific gas constant for atmosphere

	########################
	###Form functions to compute the dry and moist adiabats, the stratospheric temperature, and the overall temperature
	########################
	def T_dry_func(P): #constant c_p_co2
		return T_0*(P/P_0)**(R_atm/c_p)


	def T_sat_func(P):
		return thermo.t_sat_co2_fanale(P)
		
	###Establish a check: if the surface temperature is less than the saturation temperature at a given pressure, the atmosphere will undergo collapse and this formalism is not valid. 
	T_sat_func_0=T_sat_func(P_0)
	if T_0<T_sat_func_0:
		print 'T_0 is below T_sat(P_0), atmospheric collapse occurs'
		print 'T_0 >=', T_sat_func_0, 'K required'
		sys.exit()

	###Establish the breakpoints between different atmospheric layers
	#To get T_moist and P_moist, the T, P where the moist adiabat kicks in: find where the moist adiabat curve crosses the dry adiabat curve.
	def dry_moist_transition(P):
		return T_sat_func(P)-T_dry_func(P)

	P_moist_0=scipy.optimize.brentq(dry_moist_transition, P_0, 0.1) #estimate solution numerically, assumes zero occurs at P in range P_0 to 0.1 barye (0.1 bar)
	T_moist_0=T_dry_func(P_moist_0)

	####Check:
	###print (T_sat_func(P_moist_0)-T_dry_func(P_moist_0))/T_dry_func(P_moist_0) #if small (~1e-15), is OK...and seems to be 1e-16!


	#Already know P_strat_0, the pressure where the stratosphere starts. Now, get T_strat, the temperature of the stratosphere. Get this by assuming isothermal stratosphere following discussion with Robin on 4/18/16, coupled with assumption of continuity from the moist adiabat. Will require sensitivity tests to ensure temperatures ~20 K on either side do nothing. 
	if P_0<=P_strat_0: #if P_0 is less than P_strat_0, we have an all-stratosphere atmosphere which in our model is isothermal (strat only)
		T_strat_0=T_0
	elif P_moist_0>P_strat_0: #otherwise, if we are able to access a moist adiabat regime (strat+dry+moist)
		T_strat_0=T_sat_func(np.array([P_strat_0])) #Stratospheric temperature in K.
	else: #otherwise, if we have only a dry adiabat+stratosphere (strat+dry)
		T_strat_0=T_dry_func(np.array([P_strat_0])) #Stratospheric temperature in K.

	def T_strat_func(P):
		return 0.0*P+T_strat_0


	###Now, establish overall atmospheric temperature profile function. You determine which temperature to use in each bin by choosing the largest temperature, i.e. the slowest decline in temperature with altitude. This mimics the effect of letting radiative, dry lapse, or condensation set your temperature. Difference between wet and dry lapse rate tells you how much energy from condensation was released, and hence how much cloud there must be.
	def T_atm_func(P):
		if T_0==T_strat_0: #this is the pure stratosphere case
			T_atm=P*0.0+T_strat_0
		elif T_moist_0<=T_strat_0: #This is the case where you have just a dry and stratospheric regime (no moist)
			if type(P)==float: #If you get just a single float as input, you can't treat in the same way
				if (P>P_strat_0):
					return T_dry_func(P)
				if (P<=P_strat_0):
					return T_strat_func(P)
			else:
				inds0=np.where(P>P_strat_0)
				inds2=np.where(P<=P_strat_0)
				
				T_atm=np.zeros(np.shape(P))
				T_atm[inds0]=T_dry_func(P[inds0])
				T_atm[inds2]=T_strat_func(P[inds2])	
		elif T_moist_0>T_strat_0: #This is the case where you have a dry, moist, and stratospheric regime
			if type(P)==float: #If you get just a single float as input, you can't treat in the same way
				if (P>P_moist_0):
					return T_dry_func(P)
				if ((P<=P_moist_0) & (P>P_strat_0)):
					return T_sat_func(P)
				if (P<=P_strat_0):
					return T_strat_func(P)
			else:
				inds0=np.where(P>P_moist_0)
				inds1=np.where((P<=P_moist_0) & (P>P_strat_0))
				inds2=np.where(P<=P_strat_0)
				
				T_atm=np.zeros(np.shape(P))
				T_atm[inds0]=T_dry_func(P[inds0])
				T_atm[inds1]=T_sat_func(P[inds1])
				T_atm[inds2]=T_strat_func(P[inds2])
		else: #I have no idea how any other case could be accessed, but might as well add handling
			print 'Unanticipated value for one of the critical temperatures'
			sys.exit()
		return T_atm

	########################
	###Partition the atmosphere into layers, initialize variables to hold relevant parameters
	########################
	#Dry CO2 pressures
	P_edges=P_0*np.exp(-np.arange(0,10.1, step=0.01)) #These are the edges of the pressure bins
	P_centers=np.sqrt(P_edges[0:-1]*P_edges[1:]) #centers of pressure bins, determined by geometric mean

	########################
	###Compute P-T profiles
	########################
	#Assumes thermodynamics totally CO2-dominated
	T_dry_edges=T_dry_func(P_edges)
	T_sat_edges=T_sat_func(P_edges)
	T_strat_edges=T_strat_func(P_edges)

	T_atm_centers=T_atm_func(P_centers)
	T_atm_edges=T_atm_func(P_edges)

	#########################
	####Compute H2O Saturation Level
	#########################
	if T_0>273.:
		P_h2o_sat_edges=thermo.p_sat_h2o_liquid_wagner(T_atm_edges) #if surface supports liquid water, use liquid water water vapor saturation curve
	else:
		P_h2o_sat_edges=thermo.p_sat_h2o_ice_wagner(T_atm_edges) #otherwise use ice saturation curve


	#########################
	####Compute altitudes corresponding to each pressure level
	#########################
	####Way 1: Do by assuming isothermal atmosphere in each layer, and using hydrostatic equilibrium equation
	z_edges=np.zeros(np.shape(P_edges))
	z_centers=np.zeros(np.shape(P_centers))
	z_widths=np.zeros(np.shape(P_centers))

	for ind in range(0, len(P_centers)):
		H=k*T_atm_centers[ind]/(mmm*g) #scale height within the layer
		z_widths[ind]=-H*np.log(P_edges[ind+1]/P_edges[ind]) #delta-z spanned by the layer
		z_edges[ind+1]=z_widths[ind]+z_edges[ind] #add to the zero point to get absolute altitude
		z_centers[ind]=z_edges[ind]+-H*np.log(P_centers[ind]/P_edges[ind])

	###Way 2: integrate equation for hydrostatic equilibrium
	###define function to get z(P)
	def integrand(P):
		return -(k*T_atm_func(P))/(mmm*g*P)

	def altitude_pressure(P):
		z=np.zeros(np.shape(P))
		for ind in range(0, len(z)):
			z[ind]=scipy.integrate.quad(integrand, P_0, P[ind], epsrel=1.e-5, epsabs=0, limit=200)[0] #1e-5 accuracy
		return z

	####Test difference between both methods
	#z_centers_alt=altitude_pressure(P_centers)
	#z_edges_alt=altitude_pressure(P_edges)
	#z_widths_alt=z_edges_alt[1:]-z_edges_alt[:-1]
	#fracdiff_z=(z_centers_alt-z_centers)/z_centers
	#print np.max(fracdiff_z)
	#print np.min(fracdiff_z)
	##agree to <1%

	#########################
	####Assuming an atmosphere that is fully saturated in H2O until the tropopause, then maintains constant mixing ratio of water vapor, compute total pressures and molar concentrations of CO2 and H2O at layer boundaries.
	#########################
	conc_h2o=P_h2o_sat_edges/(P_h2o_sat_edges+P_edges)#assume fully saturated in H2O...
	conc_h2o_strat=(conc_h2o[T_atm_edges<=T_strat_0])[0]
	conc_h2o[T_atm_edges<=T_strat_0]=conc_h2o_strat #...until hits stratosphere.

	conc_co2=1.-conc_h2o

	P_tot_edges=P_edges/conc_co2 #get total atmospheric pressure, H2O+CO2

	n_co2=P_edges/(k*T_atm_edges) #Number density of CO2 
	n_h2o=P_tot_edges*conc_h2o/(k*T_atm_edges) #number density of H2O vapor
	n_tot=P_tot_edges/(k*T_atm_edges) #number density of total atmosphere (H2O+CO2)

	print np.max(np.abs((n_co2-P_tot_edges*conc_co2/(k*T_atm_edges))/n_co2)) #Two ways of computing the CO2 number density profile...if everything is working right, this quantity should be very close to 0.

	#########################
	####Compute CO2 condensation for each pressure level
	#########################
	delta_T=T_sat_edges-T_dry_edges #difference between wet and dry adiabats
	delta_T[T_sat_edges<T_dry_edges]=0. #Where the dry adiabat temperature exceeds the wet adiabat temperature, there is no condensation
	delta_T[T_sat_edges<T_strat_edges]=0. #Where the stratospheric temperature exceeds the wet adiabat temperature, there is no condensation

	n_co2_cond=(mmm/m_co2)*(c_p/L_co2)*delta_T*n_co2 #currently assuming constant c_p, L_co2



	#########################
	###Print Results in Usable Format
	#########################
	####Form T/P Profile
	towrite_tp=np.zeros([len(P_edges),4])
	towrite_tp[:,0]=z_edges #altitude in cm
	towrite_tp[:,1]=T_atm_edges#temperature in K
	towrite_tp[:,2]=n_tot #number density in cm**-3
	towrite_tp[:,3]=P_tot_edges*barye2bar #Pressure in bar
	np.savetxt('./TPProfiles/'+savefilename+'_tpprofile.dat', towrite_tp, delimiter='	', fmt='%1.7e', newline='\n', header='\n'.join(['Formed from form_atmospheric_profiles_paper_model.py','Z (cm)	T (K)	DEN (cm**-3)	P (bar)']))

	####Form Molar Concentration File
	towrite_mc=np.zeros([len(P_edges),9])
	towrite_mc[:,0]=towrite_tp[:,0] #altitude in cm
	towrite_mc[:,1]+=0. #N2
	towrite_mc[:,2]=conc_co2#CO2
	towrite_mc[:,3]=conc_h2o#H2O
	towrite_mc[:,4]=0. #CH4
	towrite_mc[:,5]=0. #SO2
	towrite_mc[:,6]=0. #O2
	towrite_mc[:,7]=0. #O3
	towrite_mc[:,8]=0. #H2S
	np.savetxt('./MolarConcentrations/'+savefilename+'_molarconcentrations.dat', towrite_mc, delimiter='	', fmt='%1.7e', newline='\n', header='\n'.join(['Formed from form_atmospheric_profiles_paper_model.py','Z (cm)		N2	CO2	H2O	CH4	SO2	O2	O3	H2S']))


	#########################
	###Plot Results
	#########################
	###First, plot dry adiabat
	fig, (ax1, ax2)=plt.subplots(2, figsize=(8,10), sharey=True)

	ax1.set_title('T-P Profile')
	ax1.plot(T_atm_edges, P_edges*barye2bar, color='black',linestyle='--', label='Atmosphere')
	ax1.plot(T_strat_edges, P_edges*barye2bar, color='purple',linestyle='--', label='Stratosphere')
	ax1.plot(T_sat_edges, P_edges*barye2bar, color='green',linestyle='--', label='Moist Adiabat')
	ax1.plot(T_dry_edges, P_edges*barye2bar, color='red',linestyle='--', label='Dry Adiabat')
	ax1.plot(T_atm_edges, P_edges*barye2bar, color='black',linestyle='--', label='CO2+H2O')

	ax1.legend(loc='lower left', fontsize=10)
	ax1.set_ylabel('CO2 Partial Pressure (bar, dry)')
	ax1.set_xlabel('Temperature (K)')
	ax1.set_yscale('log')
	#ax1.set_ylim([np.min(P_tot_edges*barye2bar), np.max(P_tot_edges*barye2bar)])
	ax1.invert_yaxis()

	tick_locations=np.array([1., 1.e-1, 1.e-2, 1.e-3, 1.e-4])*P_0*barye2bar
	ax1b=ax1.twinx()
	ax1b.set_ylim(ax1.get_ylim())
	ax1b.set_yscale('log')
	ax1b.set_yticks(tick_locations)
	ax1b.set_yticklabels(np.round(altitude_pressure(tick_locations*bar2barye)*cm2km, 1))#(altitude_pressure(tick_locations*bar2barye)*cm2km)
	ax1b.set_ylabel('Altitude (km)')
	ax1b.minorticks_off()

	ax2.set_title('Number Densities')
	ax2.plot(n_tot,P_edges*barye2bar, color='black', label='Bulk Air\n (H2O+CO2)')
	ax2.plot(n_co2,P_edges*barye2bar, color='red', label='CO2 (g)')
	ax2.plot(n_h2o,P_edges*barye2bar, color='green', label='H2O Vapor \n(Fully Saturated)')
	ax2.plot(n_co2_cond[n_co2_cond>0],P_edges[n_co2_cond>0]*barye2bar, color='blue', label='CO2 (s)')
	ax2.plot(n_co2_cond,P_edges*barye2bar, color='blue', linestyle='--') #This is just to make it look nicer...

	ax2.legend(loc=0, fontsize=10)
	ax2.set_ylabel('CO2 Partial Pressure (bar, dry)')
	ax2.set_xlabel('Number Density (molecules/cm^3)')
	ax2.set_yscale('log')
	ax2.set_xscale('log')
	ax2.set_ylim([np.min(P_edges*barye2bar), np.max(P_edges*barye2bar)])
	ax2.invert_yaxis()

	tick_locations=np.array([1., 1.e-1, 1.e-2, 1.e-3, 1.e-4])*P_0*barye2bar
	ax2b=ax2.twinx()
	ax2b.set_ylim(ax1.get_ylim())
	ax2b.set_yscale('log')
	ax2b.set_yticks(tick_locations)
	ax2b.set_yticklabels(np.round(altitude_pressure(tick_locations*bar2barye)*cm2km, 1))#(altitude_pressure(tick_locations*bar2barye)*cm2km)
	ax2b.set_ylabel('Altitude (km)')
	ax2b.minorticks_off()

	#plt.savefig('./PrelimPlots/prelim_mars_v2.pdf', orientation='portrait',papertype='letter', format='pdf')
	#plt.show()
	
#generate_profiles_cold_dry_mars(2., 250., 'test') #Test run of function

########################
###CO2-H2O-SO2-H2S Atmosphere, fairly cold and dry but some supra-freezing possible at low altitudes and elevations (e.g. Halevy and Head 2014, Hu and Seager 2014)
########################
def generate_profiles_volcanic_mars(P_0_bar, T_0, mc_so2, mc_h2s, savefilename):
	"""
	Generates input files for a cold, dry Martian atmosphere with a high inventory of SO2/H2S due to high levels of volcanism (CO2+H2O+SO2+H2S). Thermodynamics are assumedto be totally CO2-dominated
	P_0_bar: Dry CO2 surface pressure in Bar
	T_0: surface temperature in K
	mc_so2: molar concentration of SO2, taken to be constant throughout the atmosphere
	mc_h2s: molar concentration of H2S, taken to be constant throughout the atmosphere
	savefilename: name the output files generated by the function will be saved with
	"""
	P_0=P_0_bar*bar2barye #Dry CO2 surface pressure, from bar-->barye. Specified when you assume an atmospheric thickness

	P_strat_0=0.1*bar2barye #pressure at which the stratosphere starts, based on the insight by Robinson & Catling 2013 that terrestrial triatomic atmospheres tend to have stratospheres starting at p~0.1 because that's where radiative windows open up and radiative cooling/heating start to dominate

	#Specific heat at constant pressures for gases
	c_p_co2=thermo.c_p_shomate('co2', T_0) #converted from kJ/(Kg*K) to erg/(g*K)
	c_p_h2o=1.97*1.e7 #converted from kJ/(Kg*K) to erg/(g*K), measured at 1 atm and 338-589 F ()

	#Latent heats/enthalpies
	L_co2=5.93e5*1.e4 #Heat of sublimation of CO2. Value taken from PPC Table 2.1 p 92, converted from SI (Joule/Kg) to erg/gram. Taken as constant.
	#print (L_co2/(k/m_co2))/(3138.) #should be close to 1...and is, to <0.1%


	#gas composition of atmosphere
	mmm=m_co2 #mean molecular mass in g
	c_p=c_p_co2 #mean specific heat at constant pressure for atmosphere

	R_atm=k/mmm #specific gas constant for atmosphere

	########################
	###Form functions to compute the dry and moist adiabats, the stratospheric temperature, and the overall temperature
	########################
	def T_dry_func(P): #constant c_p_co2
		return T_0*(P/P_0)**(R_atm/c_p)

	def T_sat_func(P):
		return thermo.t_sat_co2_fanale(P)
		
	###Establish a check: if the surface temperature is less than the saturation temperature at a given pressure, the atmosphere will undergo collapse and this formalism is not valid. 
	T_sat_func_0=T_sat_func(P_0)
	if T_0<T_sat_func_0:
		print 'T_0 is below T_sat(P_0), atmospheric collapse occurs'
		print 'T_0 >=', T_sat_func_0, 'K required'
		sys.exit()

	###Establish the breakpoints between different atmospheric layers
	#To get T_moist and P_moist, the T, P where the moist adiabat kicks in: find where the moist adiabat curve crosses the dry adiabat curve.
	def dry_moist_transition(P):
		return T_sat_func(P)-T_dry_func(P)

	P_moist_0=scipy.optimize.brentq(dry_moist_transition, P_0, 0.1) #estimate solution numerically, assumes zero occurs at P in range P_0 to 0.1 barye (0.1 bar)
	T_moist_0=T_dry_func(P_moist_0)

	####Check:
	###print (T_sat_func(P_moist_0)-T_dry_func(P_moist_0))/T_dry_func(P_moist_0) #if small (~1e-15), is OK...and seems to be 1e-16!


	#Already know P_strat_0, the pressure where the stratosphere starts. Now, get T_strat, the temperature of the stratosphere. Get this by assuming isothermal stratosphere following discussion with Robin on 4/18/16, coupled with assumption of continuity from the moist adiabat. Will require sensitivity tests to ensure temperatures ~20 K on either side do nothing. 
	if P_0<=P_strat_0: #if P_0 is less than P_strat_0, we have an all-stratosphere atmosphere which in our model is isothermal (strat only)
		T_strat_0=T_0
	elif P_moist_0>P_strat_0: #otherwise, if we are able to access a moist adiabat regime (strat+dry+moist)
		T_strat_0=T_sat_func(np.array([P_strat_0])) #Stratospheric temperature in K.
	else: #otherwise, if we have only a dry adiabat+stratosphere (strat+dry)
		T_strat_0=T_dry_func(np.array([P_strat_0])) #Stratospheric temperature in K.

	def T_strat_func(P):
		return 0.0*P+T_strat_0


	###Now, establish overall atmospheric temperature profile function. You determine which temperature to use in each bin by choosing the largest temperature, i.e. the slowest decline in temperature with altitude. This mimics the effect of letting radiative, dry lapse, or condensation set your temperature. Difference between wet and dry lapse rate tells you how much energy from condensation was released, and hence how much cloud there must be.
	def T_atm_func(P):
		if T_0==T_strat_0: #this is the pure stratosphere case
			T_atm=P*0.0+T_strat_0
		elif T_moist_0<=T_strat_0: #This is the case where you have just a dry and stratospheric regime (no moist)
			if type(P)==float: #If you get just a single float as input, you can't treat in the same way
				if (P>P_strat_0):
					return T_dry_func(P)
				if (P<=P_strat_0):
					return T_strat_func(P)
			else:
				inds0=np.where(P>P_strat_0)
				inds2=np.where(P<=P_strat_0)
				
				T_atm=np.zeros(np.shape(P))
				T_atm[inds0]=T_dry_func(P[inds0])
				T_atm[inds2]=T_strat_func(P[inds2])	
		elif T_moist_0>T_strat_0: #This is the case where you have a dry, moist, and stratospheric regime
			if type(P)==float: #If you get just a single float as input, you can't treat in the same way
				if (P>P_moist_0):
					return T_dry_func(P)
				if ((P<=P_moist_0) & (P>P_strat_0)):
					return T_sat_func(P)
				if (P<=P_strat_0):
					return T_strat_func(P)
			else:
				inds0=np.where(P>P_moist_0)
				inds1=np.where((P<=P_moist_0) & (P>P_strat_0))
				inds2=np.where(P<=P_strat_0)
				
				T_atm=np.zeros(np.shape(P))
				T_atm[inds0]=T_dry_func(P[inds0])
				T_atm[inds1]=T_sat_func(P[inds1])
				T_atm[inds2]=T_strat_func(P[inds2])
		else: #I have no idea how any other case could be accessed, but might as well add handling
			print 'Unanticipated value for one of the critical temperatures'
			sys.exit()
		return T_atm

	########################
	###Partition the atmosphere into layers, initialize variables to hold relevant parameters
	########################
	#Dry CO2 pressures
	P_edges=P_0*np.exp(-np.arange(0,10.1, step=0.01)) #These are the edges of the pressure bins
	P_centers=np.sqrt(P_edges[0:-1]*P_edges[1:]) #centers of pressure bins, determined by geometric mean

	########################
	###Compute P-T profiles
	########################
	#Assumes thermodynamics totally CO2-dominated
	T_dry_edges=T_dry_func(P_edges)
	T_sat_edges=T_sat_func(P_edges)
	T_strat_edges=T_strat_func(P_edges)

	T_atm_centers=T_atm_func(P_centers)
	T_atm_edges=T_atm_func(P_edges)

	#########################
	####Compute H2O Saturation Level
	#########################
	if T_0>273.:
		P_h2o_sat_edges=thermo.p_sat_h2o_liquid_wagner(T_atm_edges) #if surface supports liquid water, use liquid water water vapor saturation curve
	else:
		P_h2o_sat_edges=thermo.p_sat_h2o_ice_wagner(T_atm_edges) #otherwise use ice saturation curve


	#########################
	####Compute altitudes corresponding to each pressure level
	#########################
	####Way 1: Do by assuming isothermal atmosphere in each layer, and using hydrostatic equilibrium equation
	z_edges=np.zeros(np.shape(P_edges))
	z_centers=np.zeros(np.shape(P_centers))
	z_widths=np.zeros(np.shape(P_centers))

	for ind in range(0, len(P_centers)):
		H=k*T_atm_centers[ind]/(mmm*g) #scale height within the layer
		z_widths[ind]=-H*np.log(P_edges[ind+1]/P_edges[ind]) #delta-z spanned by the layer
		z_edges[ind+1]=z_widths[ind]+z_edges[ind] #add to the zero point to get absolute altitude
		z_centers[ind]=z_edges[ind]+-H*np.log(P_centers[ind]/P_edges[ind])

	###Way 2: integrate equation for hydrostatic equilibrium
	###define function to get z(P)
	def integrand(P):
		return -(k*T_atm_func(P))/(mmm*g*P)

	def altitude_pressure(P):
		z=np.zeros(np.shape(P))
		for ind in range(0, len(z)):
			z[ind]=scipy.integrate.quad(integrand, P_0, P[ind], epsrel=1.e-5, epsabs=0, limit=200)[0] #1e-5 accuracy
		return z

	####Test difference between both methods
	#z_centers_alt=altitude_pressure(P_centers)
	#z_edges_alt=altitude_pressure(P_edges)
	#z_widths_alt=z_edges_alt[1:]-z_edges_alt[:-1]
	#fracdiff_z=(z_centers_alt-z_centers)/z_centers
	#print np.max(fracdiff_z)
	#print np.min(fracdiff_z)
	##agree to <1%

	#########################
	####Assuming an atmosphere that is fully saturated in H2O until the tropopause, then maintains constant mixing ratio of water vapor, compute total pressures and molar concentrations of CO2 and H2O at layer boundaries.
	#########################
	conc_h2o=P_h2o_sat_edges/(P_h2o_sat_edges+P_edges)#assume fully saturated in H2O...
	conc_h2o_strat=(conc_h2o[T_atm_edges<=T_strat_0])[0]
	conc_h2o[T_atm_edges<=T_strat_0]=conc_h2o_strat #...until hits stratosphere.
	
	###Assume constant profiles for SO2, H2S:
	conc_so2=np.zeros(np.shape(conc_h2o))+mc_so2
	conc_h2s=np.zeros(np.shape(conc_h2o))+mc_h2s

	conc_co2=1.-conc_h2o-conc_so2-conc_h2s

	P_tot_edges=P_edges/conc_co2 #get total atmospheric pressure, H2O+CO2
	
	n_tot=P_tot_edges/(k*T_atm_edges) #number density of total atmosphere (H2O+CO2)
	n_co2=P_edges/(k*T_atm_edges) #Number density of CO2 
	n_h2o=n_tot*conc_h2o #number density of H2O vapor
	n_so2=n_tot*conc_so2 #number density of SO2 gas
	n_h2s=n_tot*conc_h2s #number density of H2S gas
	#all in molecules/cm**3
	
	print np.max(np.abs((n_co2-n_tot*conc_co2)/n_co2)) #Two ways of computing the CO2 number density profile...if everything is working right, this quantity should be very close to 0.
	print np.max(np.abs((n_tot-(n_co2+n_h2o+n_so2+n_h2s))/n_tot)) #Two ways of computing total number density...if everything is working, should be very close to 0.

	#########################
	####Compute CO2 condensation for each pressure level
	#########################
	delta_T=T_sat_edges-T_dry_edges #difference between wet and dry adiabats
	delta_T[T_sat_edges<T_dry_edges]=0. #Where the dry adiabat temperature exceeds the wet adiabat temperature, there is no condensation
	delta_T[T_sat_edges<T_strat_edges]=0. #Where the stratospheric temperature exceeds the wet adiabat temperature, there is no condensation

	n_co2_cond=(mmm/m_co2)*(c_p/L_co2)*delta_T*n_co2 #currently assuming constant c_p, L_co2



	#########################
	###Print Results in Usable Format
	#########################
	####Form T/P Profile
	towrite_tp=np.zeros([len(P_edges),4])
	towrite_tp[:,0]=z_edges #altitude in cm
	towrite_tp[:,1]=T_atm_edges#temperature in K
	towrite_tp[:,2]=n_tot #number density in cm**-3
	towrite_tp[:,3]=P_tot_edges*barye2bar #Pressure in bar
	np.savetxt('./TPProfiles/'+savefilename+'_tpprofile.dat', towrite_tp, delimiter='	', fmt='%1.7e', newline='\n', header='\n'.join(['Formed from form_atmospheric_profiles_paper_model.py','Z (cm)	T (K)	DEN (cm**-3)	P (bar)']))

	####Form Molar Concentration File
	towrite_mc=np.zeros([len(P_edges),9])
	towrite_mc[:,0]=towrite_tp[:,0] #altitude in cm
	towrite_mc[:,1]+=0. #N2
	towrite_mc[:,2]=conc_co2#CO2
	towrite_mc[:,3]=conc_h2o#H2O
	towrite_mc[:,4]=0. #CH4
	towrite_mc[:,5]=conc_so2 #SO2
	towrite_mc[:,6]=0. #O2
	towrite_mc[:,7]=0. #O3
	towrite_mc[:,8]=conc_h2s #H2S
	np.savetxt('./MolarConcentrations/'+savefilename+'_molarconcentrations.dat', towrite_mc, delimiter='	', fmt='%1.7e', newline='\n', header='\n'.join(['Formed from form_atmospheric_profiles_paper_model.py','Z (cm)		N2	CO2	H2O	CH4	SO2	O2	O3	H2S']))


	#########################
	###Plot Results
	#########################
	###First, plot dry adiabat
	fig, (ax1, ax2)=plt.subplots(2, figsize=(8,10), sharey=True)

	ax1.set_title('T-P Profile')
	ax1.plot(T_atm_edges, P_edges*barye2bar, color='black',linestyle='--', label='Atmosphere')
	ax1.plot(T_strat_edges, P_edges*barye2bar, color='purple',linestyle='--', label='Stratosphere')
	ax1.plot(T_sat_edges, P_edges*barye2bar, color='green',linestyle='--', label='Moist Adiabat')
	ax1.plot(T_dry_edges, P_edges*barye2bar, color='red',linestyle='--', label='Dry Adiabat')
	ax1.plot(T_atm_edges, P_edges*barye2bar, color='black',linestyle='--', label='CO2+H2O')

	ax1.legend(loc='lower left', fontsize=10)
	ax1.set_ylabel('CO2 Partial Pressure (bar, dry)')
	ax1.set_xlabel('Temperature (K)')
	ax1.set_yscale('log')
	#ax1.set_ylim([np.min(P_tot_edges*barye2bar), np.max(P_tot_edges*barye2bar)])
	ax1.invert_yaxis()

	tick_locations=np.array([1., 1.e-1, 1.e-2, 1.e-3, 1.e-4])*P_0*barye2bar
	ax1b=ax1.twinx()
	ax1b.set_ylim(ax1.get_ylim())
	ax1b.set_yscale('log')
	ax1b.set_yticks(tick_locations)
	ax1b.set_yticklabels(np.round(altitude_pressure(tick_locations*bar2barye)*cm2km, 1))#(altitude_pressure(tick_locations*bar2barye)*cm2km)
	ax1b.set_ylabel('Altitude (km)')
	ax1b.minorticks_off()

	ax2.set_title('Number Densities')
	ax2.plot(n_tot,P_edges*barye2bar, color='black', label='Bulk Air\n (H2O+CO2)')
	ax2.plot(n_co2,P_edges*barye2bar, color='red', label='CO2 (g)')
	ax2.plot(n_h2o,P_edges*barye2bar, color='green', label='H2O Vapor \n(Fully Saturated)')
	ax2.plot(n_so2,P_edges*barye2bar, color='red', label='SO2')
	ax2.plot(n_h2s,P_edges*barye2bar, color='orange', label='H2S')
	ax2.plot(n_co2_cond[n_co2_cond>0],P_edges[n_co2_cond>0]*barye2bar, color='blue', label='CO2 (s)')
	ax2.plot(n_co2_cond,P_edges*barye2bar, color='blue', linestyle='--') #This is just to make it look nicer...

	ax2.legend(loc=0, fontsize=10)
	ax2.set_ylabel('CO2 Partial Pressure (bar, dry)')
	ax2.set_xlabel('Number Density (molecules/cm^3)')
	ax2.set_yscale('log')
	ax2.set_xscale('log')
	ax2.set_ylim([np.min(P_edges*barye2bar), np.max(P_edges*barye2bar)])
	ax2.invert_yaxis()

	tick_locations=np.array([1., 1.e-1, 1.e-2, 1.e-3, 1.e-4])*P_0*barye2bar
	ax2b=ax2.twinx()
	ax2b.set_ylim(ax1.get_ylim())
	ax2b.set_yscale('log')
	ax2b.set_yticks(tick_locations)
	ax2b.set_yticklabels(np.round(altitude_pressure(tick_locations*bar2barye)*cm2km, 1))#(altitude_pressure(tick_locations*bar2barye)*cm2km)
	ax2b.set_ylabel('Altitude (km)')
	ax2b.minorticks_off()

	#plt.savefig('./PrelimPlots/prelim_mars_v2.pdf', orientation='portrait',papertype='letter', format='pdf')
	#plt.show()
	
#generate_profiles_cold_dry_mars(2., 250., 'test') #test run